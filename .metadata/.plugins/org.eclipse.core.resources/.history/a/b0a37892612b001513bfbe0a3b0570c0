package games;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.swing.JPanel;
import javax.swing.Timer;


/**
 * 
 * Tetris Video Game main program
 *
 */
@SuppressWarnings("serial")
public class Tetris extends JPanel implements KeyListener, ActionListener,
		MouseListener {

	private final static int AMOUNT_OF_BLOCKS = 6;
	private final static int ROTATE_AMOUNT = 3;

	private final static int BLOCK_WIDTH = 4;
	private final static int BLOCK_HEIGHT = 4;

	private final static int BLOCK_POS_X = 175;
	private final static int BLOCK_POS_Y = 50;
	private final static int BLOCK_SIZE = 25;

	private final static int BOARD_WIDTH = 10;
	private final static int BOARD_HEIGHT = 20;
	private final static int BOARD_POS_X = 125;
	private final static int BOARD_POS_Y = 75;

	private final static int NEXT_BLOCK_POS_X = 475;
	private final static int NEXT_BLOCK_POS_Y = 125;
	private final static int BLOCK_THEMES_TOTAL = 10;
	private final static int BKGD_TOTAL = 15;
	private final static int BLOCK_SPEED = 550;

	private final static int GAME_POINTS = 250;
	private final static int GAME_MOVE_UP_LEVEL = 20;

	private int gameSpeed;
	private Timer gameTimer;

	private int blockType;
	private int nextBlockType;
	private int rotateBlock;
	private int blockLocateX;
	private int blockLocateY;

	private int totalScore;
	private int gameLevel;
	private int countLines;
	private int totalLines;

	private boolean pauseGame;
	private boolean turnOnGrid;
	private boolean endGame;
	private boolean controlKeyBox;

	private boolean soundOn;
	private boolean justStarted;
	private boolean quitGame;

	private boolean overrideCommand;

	private GameObject gameBlock;
	private GameObject gameBoard;
	private GameObject nextBlock;

	private BufferedImage[][] blockImage;
	private BufferedImage[] backgroundImage;
	private BufferedImage endGameImage;
	private BufferedImage soundOnImage;
	private BufferedImage soundOffImage;
	private BufferedImage controlKeyImage;
	private BufferedImage escKeyImage;

	private BufferedImage logoTextLevel;
	private BufferedImage logoTextLines;
	private BufferedImage logoTextNext;
	private BufferedImage logoTextScore;

	private int animateTime;
	private int blockTheme;
	private int backgroundTheme;
	private GameImage image;

	public Tetris() {
		// create game blocks
		gameBlock = new GameObject();
		// create game board
		gameBoard = new GameObject(); 
		// create next block
		nextBlock = new GameObject(); 

		
		/*
		 *  set space for block image
		 */
		blockImage = new BufferedImage[BLOCK_THEMES_TOTAL][7]; 
		
		/*
		 * set space for background image
		 */
		backgroundImage = new BufferedImage[BKGD_TOTAL]; 
		
		// turn sound on
		soundOn = true; 
		
		// initiate class to load image
		image = new GameImage(); 
		
		// load all image for tetris
		loadGameImage(); 
		
		// set the type of next brick
		setNextBlock(); 
		
		// initiate more values
		setGame(); 
		
		// create timer for tetris
		gameTimer = new Timer(gameSpeed, this); 

		/*
		 * mouse and key listener
		 */
		this.addMouseListener(this);
		this.addKeyListener(this);
		this.setFocusable(true);
		this.requestFocus();

	}

	public void setGame() {
		
		
		// initiate values for tetris blocks
		setBlocks(); 

		
		/*
		 * set game board size and location
		 */
		int[] boardGrid = new int[BOARD_WIDTH * BOARD_HEIGHT];
		gameBoard.setObject(boardGrid, BOARD_WIDTH, BOARD_HEIGHT, BLOCK_SIZE);
		gameBoard.setPosition(BOARD_POS_X, BOARD_POS_Y);

		gameSpeed = BLOCK_SPEED;
		totalScore = 0;
		gameLevel = 1;

		totalLines = 0;
		countLines = 0;

		pauseGame = false;
		endGame = false;
		controlKeyBox = false;

		turnOnGrid = false;
		justStarted = true;
		quitGame = false;

		overrideCommand = false;

		blockTheme = BLOCK_THEMES_TOTAL;
		backgroundTheme = 0;
		
		// initiate new blocks
		setBlocks(); 

	}

	public boolean quit() {
		return endGame;
	}

	public void resetGame() {
		setGame();
	}

	public BufferedImage getImage(String filename) {
		BufferedImage tempImage = null;

		String filePath = "/images/" + filename;
		try {

			tempImage = ImageIO.read(getClass().getResourceAsStream(filePath));

		}

		catch (Exception ex) {
			System.out.println("file " + filePath + " not found");
		}

		return tempImage;
	}

	public void loadGameImage() {
		String[][] pic = {

				{ "block_bold_cyan.png", "block_bold_yellow.png",
						"block_bold_blue.png", "block_bold_lightgreen.png",
						"block_bold_darkblue.png", "block_bold_green.png",
						"block_bold_red.png" },

				{ "block_pushbutton_blue.png", "block_pushbutton_green.png",
						"block_pushbutton_red.png",
						"block_pushbutton_purple.png",
						"block_pushbutton_orange.png",
						"block_pushbutton_yellow.png",
						"block_pushbutton_cyan.png" },

				{ "iron_blue_block.png", "iron_darkblue_block.png",
						"iron_green_block.png", "iron_orange_block.png",
						"iron_purple_block.png", "iron_red_block.png",
						"iron_yellow_block.png" },

				{ "block_metal_blue.png", "block_metal_green.png",
						"block_metal_red.png", "block_metal_purple.png",
						"block_metal_orange.png", "block_metal_yellow.png",
						"block_metal_cyan.png" },

				{ "block_gel_blue.png", "block_gel_green.png",
						"block_gel_red.png", "block_gel_purple.png",
						"block_gel_orange.png", "block_gel_yellow.png",
						"block_gel_cyan.png" },

				{ "emoji_blue.png", "emoji_darkblue.png", "emoji_green.png",
						"emoji_pink.png", "emoji_purple.png", "emoji_red.png",
						"emoji_yellow.png" },

				{ "block_mushroom_blue02.png", "block_mushroom_brown.png",
						"block_mushroom_green.png",
						"block_mushroom_orange.png",
						"block_mushroom_purple.png",
						"block_mushroom_red02.png",
						"block_mushroom_lightblue.png" },

				{ "block_button_blue.png", "block_button_green.png",
						"block_button_red.png", "block_button_purple.png",
						"block_button_orange.png", "block_button_yellow.png",
						"block_button_cyan.png" },

				{ "block_dragonball_01.png", "block_dragonball_02.png",
						"block_dragonball_03.png", "block_dragonball_04.png",
						"block_dragonball_05.png", "block_dragonball_06.png",
						"block_dragonball_07.png" },

				{ "block_ball_baseball.png", "block_ball_baskitball.png",
						"block_ball_beach.png", "block_ball_football.png",
						"block_ball_soccer.png", "block_ball_volley.png",
						"block_ball_yellow_soccer.png" } };
		
		/*
		 * load brick images
		 */
		for (int k = 0; k < BLOCK_THEMES_TOTAL; k++)
			for (int i = 0; i < 7; i++)
				blockImage[k][i] = getImage(pic[k][i]);

		String[] bkgdImage = { "bkgd_building.jpg", "bkgd_gravel.jpg",
				"bkgd_food.jpg", "bkgd_live.jpg", "bkgd_wave.jpg",
				"bkgd_playgame.jpg", "bkgd_crack.jpg", "bkgd_mario.jpg",
				"bkgd_colors.jpg", "bkgd_rockandsky.jpg",
				"bkgd_grey_bricks.jpg", "bkgd_earth.jpg",
				"bkgd_darkred_bricks.jpg", "bkgd_jungle.jpg",
				"bkgd_black_bricks.jpg" };

		
		/*
		 * load background wallpaper
		 */
		for (int i = 0; i < BKGD_TOTAL; i++)
			backgroundImage[i] = image.getImage(bkgdImage[i]);
		
		/*
		 * load message images
		 */
		endGameImage = image.getImage("logo_endgame.png");
		escKeyImage = image.getImage("logo_press_esc.png");
		controlKeyImage = image.getImage("logo_control_keys.png");
		soundOnImage = image.getImage("logo_sound_on.png");
		soundOffImage = image.getImage("logo_sound_off.png");

		
		/*
		 * load logo images
		 */
		logoTextLevel = image.getImage("logo_text_level.png");
		logoTextLines = image.getImage("logo_text_lines.png");
		logoTextNext = image.getImage("logo_text_next.png");
		logoTextScore = image.getImage("logo_text_score.png");

	}

	public void playSound(int index) {
		String[] filename = { "instant_drop.wav", "remove_blocks.wav",
				"rotate.wav", "sound8.wav" };

		if (soundOn)
			loadGameSound(filename[index]);
	}

	public void loadGameSound(String filename) {

		try {

			Clip clip = AudioSystem.getClip();

			AudioInputStream inputStream = AudioSystem
					.getAudioInputStream(Tetris.class.getResource("/sounds/"
							+ filename));
			clip.open(inputStream);
			clip.start();

		} catch (Exception ex) {
			System.out.println("can't find " + filename + " file");
		}

	}

	public boolean isTimeAnimated() {
		// check if animation is on
		if (animateTime % 2 > 0) 
			return true;
		return false;

	}

	public void checkGameBoardRow() {
		// check if brick row is fill
		while (gameBoard.isRowFull()) { 
			gameBoard.invertRow();
			countLines++;
		}
		// if row is fill start animation
		if (countLines > 0) 
			animateTime = 5;

	}

	public void setGameStatistics() {

		
		/*
		 * calculate game points for each row that is fill
		 */
		if (countLines > 0) {
			totalScore += countLines * GAME_POINTS;
			totalLines += countLines;
			countLines = 0;
		}
		// cheat code to move up a level
		if (!overrideCommand) 
			gameLevel = (totalLines / GAME_MOVE_UP_LEVEL) + 1; 
	}

	private void setRenderingFonts(Graphics2D g2d) {

		
		/*
		 * add anti aliasing to
		 * system fonts
		 * 
		 */
		RenderingHints renderHints = new RenderingHints(
				RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);

		renderHints.put(RenderingHints.KEY_RENDERING,
				RenderingHints.VALUE_RENDER_QUALITY);

		g2d.setRenderingHints(renderHints);
	}

	@Override
	public void paintComponent(Graphics g) {
		this.paintComponents(g);
		Graphics2D g2d = (Graphics2D) g;
		
		// add anti aliasing to fonts
		setRenderingFonts(g2d); 
		
		// update all brick values
		updateTetris(); 
		int tempLevel = gameLevel;
		
		// start game timer
		gameTimer.start(); 
		
		// check if row is fill with bricks
		checkGameBoardRow(); 

		
		/*
		 * if row is fill with bricks
		 * then remove bricks and
		 * start animateTime
		 * 
		 */
		if (animateTime == 0)
			gameBoard.dropBlock();
		else
			animateTime--;
		// if brick is remove play sound
		if (animateTime == 4) 
			playSound(1);
		
		// get game points, level and line count
		setGameStatistics(); 
		// as level increase so does speed
		setGameSpeed(); 
		// draw all image
		drawGameSprites(g2d); 

		
		/*
		 * if player change level
		 * then change background image
		 * 
		 */
		if (tempLevel != gameLevel)
			changeBkgdTheme();

	}

	public void pressAnyKey(Graphics g2d) {
		g2d.drawString("Press any key to continue...", 100, 70);

	}

	public void drawGameMessage(Graphics g2d) {
		
		// display quit message
		if (quitGame) { 
			pressAnyKey(g2d);
			g2d.drawImage(endGameImage, 175, 200, null);
		// display just started message	
		} else if (justStarted) { 
			pressAnyKey(g2d);
			g2d.drawImage(controlKeyImage, 100, 100, null);
		// display instruction box
		} else if (controlKeyBox) 
			g2d.drawImage(controlKeyImage, 100, 100, null);
		
		// sound on or off image
		if (soundOn) 
			g2d.drawImage(soundOnImage, 475, 525, 35, 35, null);
		else
			g2d.drawImage(soundOffImage, 475, 525, 35, 35, null);
		
		// display message to pause game
		g2d.drawImage(escKeyImage, 100, 0, null); 
													 
	}

	public void drawGameStatistics(Graphics g2d) {
		g2d.setColor(Color.white);

		g2d.setFont(new Font("Courier", Font.BOLD, 20));

		g2d.drawImage(logoTextNext, 475, 90, null);

		g2d.drawImage(logoTextLevel, 475, 300, null);
		g2d.drawString(Integer.toString(gameLevel), 475, 350);

		g2d.drawImage(logoTextLines, 475, 375, null);
		g2d.drawString(Integer.toString(totalLines), 475, 425);

		g2d.drawImage(logoTextScore, 475, 450, null);
		g2d.drawString(Integer.toString(totalScore), 475, 500);

	}

	public void drawGameSprites(Graphics2D g2d) {

		Draw draw = new Draw();

		
		// display image if isTimeAnimated is true
		draw.showAllImage(isTimeAnimated());

		/*
		 * tetris brick image start at the
		 * top of the game board a bit outside
		 * the bound, setCutOff remove part of 
		 * the brick image that is outside the 
		 * bound of the game board
		 * 
		 */
		draw.setCutOff(75);

		if (blockTheme == BLOCK_THEMES_TOTAL) {

			// display background wallpaper
			g2d.drawImage(backgroundImage[backgroundTheme], 0, 0, getWidth(),
					getHeight(), null);
			
			// show next tetris brick
			draw.display(g2d, nextBlock); 
			
			// display game grid
			if (turnOnGrid) 
				draw.displayCheckerImage(g2d, gameBoard);

			else
				draw.setBackground(g2d, gameBoard, Color.BLACK);
			// draw game board
			draw.display(g2d, gameBoard); 
			// draw tetris brick
			draw.display(g2d, gameBlock); 

			// g2d.fillRoundRect(425,275, 175,300,30,30);
			// g2d.fillRect(getImage("background_crack.jpg",0,0,175,300,null));
			// g2d.drawImage(backgroundImage[9], 425, 275, 175, 300, null);
		} else {
			
			// display background wallpaper
			g2d.drawImage(backgroundImage[backgroundTheme], 0, 0, getWidth(),
					getHeight(), null);
			
			// show next tetris brick
			draw.display(g2d, nextBlock, blockImage[blockTheme]); 

			// display game grid
			if (turnOnGrid) 
				draw.displayCheckerImage(g2d, gameBoard);

			else
				draw.setBackground(g2d, gameBoard, Color.BLACK);

			// draw game board
			draw.display(g2d, gameBoard, blockImage[blockTheme]); 
			
			// draw tetris board										
			draw.display(g2d, gameBlock, blockImage[blockTheme]); 

		}

		// background for statistics, score, levels, and sound image
		g2d.fillRoundRect(425, 275, 175, 300, 30, 30);

		// display game statistics and message to player
		drawGameStatistics(g2d);
		drawGameMessage(g2d);

	}

	public void addObjectToBackground() {
		// add tetris brick to game board
		gameBoard.addObject(gameBlock); 
		// update tetris brick value
		setBlocks(); 
	}

	public void updateTetris() {

		
		// set new tetris block type, size, and location
		//int[] nextGameBlock = GameBlocks.getBlock(blockType, rotateBlock);
		//gameBlock.mikeSetObject();
		gameBlock.mikeSetBlockDimensions(BLOCK_WIDTH, BLOCK_HEIGHT,
				BLOCK_SIZE);
		gameBlock.mikeSetBlockType(blockType);
		//gameBlock.setObject(nextGameBlock, BLOCK_WIDTH, BLOCK_HEIGHT,
		//		BLOCK_SIZE);
		gameBlock.setPosition(blockLocateX, blockLocateY);
	}

	public void setNextBlock() {
		
		// randomly get new tetris brick
		Random randomizer = new Random();
		nextBlockType = randomizer.nextInt(AMOUNT_OF_BLOCKS + 1);
		
		// set tetris brick size
		int[] nextGameBlock = GameBlocks.getBlock(nextBlockType, 0);
		nextBlock.setObject(nextGameBlock, BLOCK_WIDTH, BLOCK_HEIGHT,
				BLOCK_SIZE);

		// set tetris brick location
		nextBlock.setPosition(NEXT_BLOCK_POS_X, NEXT_BLOCK_POS_Y);
	}

	public void setBlocks() {
		
		// set the rotate, location, and block type for tetris brick
		rotateBlock = 0;
		blockLocateX = BLOCK_POS_X;
		blockLocateY = BLOCK_POS_Y;

		blockType = nextBlockType;
		
		// set new values for the next tetris brick
		setNextBlock(); 
	}

	@Override
	public void keyPressed(KeyEvent e) {

		// temporally hold tetris brick value
		int tempRotateBlock = rotateBlock;
		int tempBlockLocateX = blockLocateX;
		int tempBlockLocateY = blockLocateY;

		int keyPress = e.getKeyCode(); // get key player press
		boolean bRotate = false;

		// if player died or choose to quit
		if (endGame) {
			keyPress = 0;
			quitGame = false;
		}

		
		/*
		 * pause game so player
		 * can read instructions
		 * before game start
		 * 
		 */
		if (justStarted) {
			keyPress = 0;
			justStarted = false;

		// if player quit game
		} else if (quitGame) { 
			keyPress = 0;
			endGame = true;

		}
		// read which key is press
		switch (keyPress) { 

		case KeyEvent.VK_UP:
			if (rotateBlock < ROTATE_AMOUNT)
				rotateBlock++;
			else
				rotateBlock = 0;
			
			bRotate = true;
			break;

		case KeyEvent.VK_DOWN:
			blockLocateY += BLOCK_SIZE;
			break;

		case KeyEvent.VK_LEFT:
			blockLocateX += -BLOCK_SIZE;
			break;

		case KeyEvent.VK_RIGHT:
			blockLocateX += BLOCK_SIZE;
			break;

		case KeyEvent.VK_SPACE:
			if (pauseGame)
				break;

			/*
			 * instantly drop brick and
			 * check if brick is in bound
			 * 
			 */
			while (gameBoard.inBound(gameBlock)
					&& !gameBoard.hasObject(gameBlock)) {
				tempBlockLocateY = blockLocateY;
				blockLocateY += BLOCK_SIZE;

				// update tetris values while brick is being pull down

				updateTetris();
			}
			
			// set brick new location
			blockLocateY = tempBlockLocateY; 
			
			// update tetris values
			updateTetris(); 
			
			// add brick to game board
			addObjectToBackground(); 
			
			// drop tetris brick sound
			playSound(0); 

			break;
		case KeyEvent.VK_S:
			soundOn = !soundOn;
			break;
		case KeyEvent.VK_T:
			changeGameTheme();
			break;
		case KeyEvent.VK_G:
			turnOnGrid = !turnOnGrid;
			break;
		case KeyEvent.VK_Q:
			quitGame = true;
			break;
		case KeyEvent.VK_B:
			changeBkgdTheme();
			break;
		case KeyEvent.VK_L:
			gameLevel++;
			overrideCommand = true;
			break;
		case KeyEvent.VK_ESCAPE:
		case KeyEvent.VK_P:

			
			// pause game and show control dialog box
			
			controlKeyBox = !controlKeyBox;
			pauseGame = controlKeyBox;
			break;
		}
		
		
		// update tetris brick with new values
		if (pauseGame) {
			rotateBlock = tempRotateBlock;
			blockLocateX = tempBlockLocateX;
			blockLocateY = tempBlockLocateY;
		}

		else {
			// update tetris values
			updateTetris(); 

			/*
			 * if tetris brick is inside game board
			 * and does not overlap another brick
			 * 
			 */
			if (gameBoard.inBound(gameBlock) && !gameBoard.hasObject(gameBlock)) {
				
				// rotate tetris brick sound
				if (bRotate)
					playSound(2); 

				this.repaint();
			}

			// update tetris brick with old values
			else {
				rotateBlock = tempRotateBlock;
				blockLocateX = tempBlockLocateX;
				blockLocateY = tempBlockLocateY;
				updateTetris();
			}
		}
		
		gameBlock.mikeRotateBlock(rotateBlock);
		gameBlock.setPosition(blockLocateX, blockLocateY);
	}

	@Override
	public void keyTyped(KeyEvent e) {
	}

	@Override
	public void keyReleased(KeyEvent e) {
	}

	@Override
	public void actionPerformed(ActionEvent e) {

		/*
		 * pause game for certain action
		 * for example player pause game,
		 * just started, or brick animation
		 * 
		 */
		if (pauseGame || animateTime > 0 || justStarted)
			repaint();
		else if (!quitGame && !endGame)
			// pull tetris brick down
			dropBlocks(); 

	}

	public void dropBlocks() {

		int tempBlockLocateY = blockLocateY;

		blockLocateY += BLOCK_SIZE;
		
		// update tetris brick values
		updateTetris();

		
		/*
		 * if brick is inside game board
		 * and not have the same brick
		 * in the same location
		 * 
		 */
		if (gameBoard.inBound(gameBlock) && !gameBoard.hasObject(gameBlock))
			repaint();

		else {
			blockLocateY = tempBlockLocateY;
			updateTetris();

			
			/*
			 * if no more tetris brick
			 * can fit on board
			 * then end game
			 * 
			 */
			if (gameBoard.hasObject(gameBlock)) {
				quitGame = true;
				playSound(3);

			} else
				// add tetris brick to game board
				addObjectToBackground(); 
			repaint();
		}
	}

	public void changeGameTheme() {
		// change background image
		changeBkgdTheme(); 
		// change block image
		changeBlockTheme(); 
	}

	public void changeBkgdTheme() {
		// first background image
		if (backgroundTheme >= backgroundImage.length - 1)
			backgroundTheme = 0; 
		else
			// next background image
			backgroundTheme++; 
	}

	public void changeBlockTheme() {
		// first block theme
		if (blockTheme >= BLOCK_THEMES_TOTAL)
			blockTheme = 0; 
		// next block theme
		else
			blockTheme++;
	}

	public void setGameSpeed() {

		/*
		 * as player advance through
		 * the levels,
		 * game speed increase
		 * 
		 */
		switch (gameLevel) {
		case 2:
			gameSpeed = 500;
			break;
		case 3:
			gameSpeed = 450;
			break;
		case 4:
			gameSpeed = 400;
			break;
		case 5:
			gameSpeed = 350;
			break;
		case 6:
			gameSpeed = 300;
			break;
		case 7:
			gameSpeed = 250;
			break;
		case 8:
			gameSpeed = 200;
			break;
		case 9:
			gameSpeed = 150;
			break;
		case 10:
			gameSpeed = 100;
			break;

		}

		
		/*
		 * change game timer speed
		 * to display brick animation
		 * 
		 */
		if (animateTime > 0)
			gameTimer.setDelay(50);
		else
			// return to normal timer speed
			gameTimer.setDelay(gameSpeed); 
	}

	@Override
	public void mouseClicked(MouseEvent e) {

		// if mouse is pointing at sound image
		boolean bHar = e.getX() > 475 && e.getX() < 499;
		boolean bVer = e.getY() > 525 && e.getY() < 560;

		// click sound image to turn on/off
		if (bHar && bVer)
			soundOn = !soundOn;
	}

	@Override
	public void mousePressed(MouseEvent e) {
	}

	@Override
	public void mouseReleased(MouseEvent e) {
	}

	@Override
	public void mouseEntered(MouseEvent e) {
	}

	@Override
	public void mouseExited(MouseEvent e) {
	}

}
